-------------------------------------------Week1-------------------------------------------


As Embedded Software Engineers we intend to maximize software portability and reliability.

It´s impossible to make everything Architecture Independent,
   As Firmware Layers still interact with hardware.
   Assembly is Architecture Dependent.

A Embedded Software Engineer needs to know how our code is moved in between CPU & Memory, 
How is stack implemented in a certain architecture.

Embedded Application Binary Interface (EABI) provides details on how a binary must be compiled
and interfaced with platform compoenents such as : 
Registers Use :
Word Size : Defines Operand Size Of The Instruction Set Architecture. 
Code/Data Storage Rrquirements : How Large is instruction,Data Types, Alignment. 
Addressing Modes : Register Addressing,Direct & Indirect.
Calling Conventions : How stack is managed, routines are called, data is passed/returned,saved staate.
Helper Functions & Libraries : More complex software operations, Floating Point match, C-standard Library.
                               Helper functions may implement functionality through software which is not
                               available to us in Hardware and ISA like for e.g. floating point support.

----------------Lec 2 : Word Size, Data Types----------------


In ARM Cortex M Microcontrollers word size is of 32 Bits meaning the CPU has 32 Bit size registers.
ARM Cortex M Instruction Set Architecture may have specific support for our 8-Bit, 16-Bit or 64 Bit Operations.

ARM has a lot of buses such as Internal System Bus ( ARM AHB) and External Peripheral Bus (APB).

The  Bus width does not neccesarily have to be the size of word.
A bus will contain both data bits,control bits,address bits.

Besides uint8_t,uint16_t,uint32_t, uint64_t, int8_t,int16_t,int32_t,int64_t types defined in stdint.h header file we also have 
uint_fast8_t,uint_fast16_t,uint_fast32_t,uint_fast64_t, 
int_fast8_t,int_fast16_t,int_fast32_t,int_fast64_t,           fast types indicate that data should be represented in a way that access 
                                                              and use of this data should occur as fast as possible in a architecture with 
                                                              at least n defined bits. However to have fast access it´s size can be increased to
                                                              the size of processor.                          
                                                              

uint_least8_t,uint_least16_t,uint_least32_t,uint_least64_t,   
int_least8_t,int_least16_t,int_least32_t,int_least64_t,       least types indicate that at least specific n bits should be   
                                                              assigned to the type.

Bool data type is introduced in C99 
We can also use typedef keyword to crete our own custom type names.


--------------------------Lec 3 : Pointers--------------------------

ARM Cortex M Architecture has a 32 Bit Pointer meaning a pointer can pointer in the entire address space i.e 2^32  
     When we declare a pointer with syntax i.e. type * ptr; 
                                                type indicates what kind of data type pointer is pointing to
                                                as pointers don´t have any type by themselves.
                                                Size of a pointer is equal to word size of the architecture.
     Whenever we dereference a pointer then we access value pointed by the address placed in pointer. As pointers memory hold 
     addresses not any values.

We can also directly address to a pointer like for e.g. address of a variable i.e. 
                              uint8_t * ptr = (uint8_t*)0x00023;  // While we have casted the value pointed out by address as 8 Bits. Here we´ve assigned address 0x00023 to pointer ptr and make sure by casting that we just only access 8 bits at that memory location and those 8 bits are of unsigned integer data type.                                            
                                                                  // As our pointer can point to a 8 bit unsigned 8 bit value.

                              uint32_t * ptr2 =(uint8_t*)0x00024 ; // Now we are accessing only 8 bits out of n bits stored at Address 0x00024                            
                              
 
typedef struct Person {
char *name;
 uint8_t age;
}Person_t;       // Name of this structure is Person_t, While we have created new type Person while assigning a new name(alias) to struct
                 // To access struct members in src file we do : Person_t p1, *ptr_p1;
                                                                 ptr_p1= &p1;
                                                                 ptr_p1->age=10; 

---------------------Lec 4 : Interacting With Memory-------------------------------

As we know in an embedded system a part from external peripheral memory inside a MCU we have three kinds of memories : 

Data Memory In SRAM  (Static Random Memory Type Of RAM)
Code Memory In Flash (ROM)
Register Memory.

In a microcontroller every peripheral controller has it´s own register memory controlling and providing the interaction in between the CPU and external pripheral units connected to
a certain peripheral interface(I2C, SPI,USB,UART e.t.c.)

We cannot access CPU registers directly through our C programming instead we need to use inline Assembly code mixed with C code for accessing these internal CPU registers.

Load and store Assembly instructions enable loading of data from RAM to CPU registers and store instruction for storing processed data back into RAM, this process is known as 
read, write and modify.

Compiler will try to minimize Load and Store operation overhead through type qualifiers such as restric,register and maybe volatile.

---------Bit Banded Regions--------

ARM Architecture provides Bit Banded Regions in the address space of (peripheral or SRAM) enabling one to perform bit-level loads and stores as each address will map to a certain bit.
Bit Banded Memory operations are good for avoiding race conditions that could be introduced by read-write modify operations.
Bit Banded operations are atomic and handled in Hardware, No CPU Load/Store instruction is involved.

-------ARM Cortex M Buses-----------

ARM provides AMBA (Advance Microcontroller Bus Architecture).
In ARM architecture our bus width is of 32 Bits and AMBA architecture allows this bus width to vary it´s size.

In AMBA (Advance Microcontroller Bus Architecture) we have several buses such as : 
AHB System Bus.
APB Periperhal Bus.
AHB Flash D-Code Bus.
AHB Flash I-Code Bus.

AHB (Advanced High Performance Bus) providing Fast/High Bandwidth Interfaces.
Private Cortex M4 Buses are : Internal Private Peripheral Bus (PPB) for SCB,NVIC,MPU.
                              External Private Peripheral Bus (PPB) for external debugging. 

AHB External Core Buses :  System Bus (AHB-Lite) for SRAM, High Speed Peripherals, Peripheral Bridge.
                           Flash Buses : I-Code Bus (For Code Memory) 
                                         D-Code Bus ( For Data Memory ) 

APB Advanced Peripheral Bus : Not Directly Connected To CPU But Through A Bridge   
                              This is a low bandwidth Bus for Communication Block,I/O Interfaces : UART,SPI,I2C,ADC, Timers e.t.c.
                              

-----------------Lec 5 : Memory Alignment-------------------


Structres are high level constructs independent of underlying hardware architecture.

The underlying ISA provides us three types of Load/Store Instructions these are : Byte,Half-Word and Word Load stores instructions.

The load/store instructions for Byte,Halfword,word are designed work on specific memory alignments i.e. they can work on certain addresses efficiently. 

Memory Alignment will have effects on both CPU and Memory Efficiency.

Unused Memory is used to pad empty memory spots(bytes are added/stuffed) until the data type can be aligned. Extra padded bytes are known as padding and this phenomenon in terms of 
C programming is called Structure padding.

Unaligned memory without padding will force the CPU to do more work to access data at addresses but will pack more data efficiently.

Bytes can be stored at any address in memory and are always aligned.

Half words, words, double words require certain address alignment : Words Need to be aligned at four bytes Boundaries(Addresses with 0x00 &0x04), Can pad maximum of three bytes.
                                                                    Doble words must aligned at eight byte boundaries or addresses end with (0x00,0x08)...
                                                                    Half Words Can only be stored at even addresses, (0x00,0x02..) thus will require one extra padded byte.

Instructions in ARM Cortex M Architecture can vary from 16 to 32 bits and are forced to be aligned at least a half word boundary and cannot support unaligned accesses. So if we
have a 16 bit instruction for storing 16 bits of data at word location and another 32 bit instruction for 32 bit data at 32 bit location then extra 16 bits will be added to the 
data stored using 16 bit instruction because we cannot have half word in remaining upper 16 bits and the other half in lower 16 bits as it does not support load/store instructions directly. The CPU will be doing multile loads and stores just to combine upper and lower half words into a single location and then perform operation on that word.

Memory alignment is useful if we want to have our program execute efficiently with fewer CPU cycles .
For Unaligned Memory when we want to pack data in order to reduce memory (Code Memory) consumption then we will be having multiple loads and stores operations in CPU decreasing execution speed of our program . 

---------------------Lec 6 : Endianness---------------

Endianness defines byte order of data in a computer system memory (Code, Data Memories ) .

There are two types of Endianess : 
Big Endian : Most Significant Byte is stored first in Memory i.e. at Lowest Address in Memroy.
Little Endian : Least Significant Byte is stored first in Memory i.e. at Lowest Address in Memory.
                                                                     
Endianness does not affect order of elements of an array and structure, it only impacts the bytes of individual elements.

Example : uint16_t arr[3] = {0x1201,0x1302}; // Here according to Big Endian MSB Byte 0x12 will be stored first in memory at
                                                lowest address and then byte 01 and same goes for bytes 0x1302

                                                                     Big Endian        Little Endian 
                                               Memory Address        Element              Element 
                                                 0x0001               0x12                  0x01
                                                 0x0002               0x01                  0x12
                                                 0x0003               0x13                  0x02
                                                 0x0004               0x02                  0x13

Some systems cannot be configured for a certain endianness order however ARM Architecture originally a Big Ednian Archtecture
allows us to change it´s endianness by resetting the processor.
ARM data Memory Endianness can be changed , Code Memory is Little Endian and it´s Endianness cannot be changed.

To change the ARM Endianness for data memory we need to set/unset Bit15 of AIRCR(Application Inteerupt & Reset Control Register).  Bit15 = 0 for Little Endian , Bit15=1 for Big Endian.

Endianness can be a big issue if we are having a communication betwwen two different architectures throguh communication bus
(I2C,SPI,UART e.t.c.) or with external peripherals, sensors, systems. In order to make two different systems with differing
Endianness we can use a function called byte swap which can change the order of corresponding endianness i.e.

For Converting 32 Bit Little Endian To 32 Bit Big Endian :

void byte_swap32(uint32_t *ptr) {

uint8_t i,temp_byte;

for(int i=0; i<2; i++){
temp_byte = *((uint8_t*)ptr+(3-i));
*((uint8_t*)ptr + (3-i))= *((uint8_t*)ptr+i);
*((uint8_t*)ptr+i)=temp_byte;
}
}


void main(){
uint32_t var = 0xABCD1234;
uint32_t *ptr =&var;
byte_swap(ptr);

while(1);
}

We can configure above program for conversion from 16 Bits as well and also for converting from Big Endian to Little Endian, note we need to lenghth of data passed from pointer for that we use sizeof(*ptr);


----------------Lec 7: Compiler Attributes---------------

We can also align our memory alignments for byte,half-word,word,double word through compiler attributes.

Compiler attributes give specific details on how to compile data for : variables, structures & Structure Memebers and Functions. However attributes are not a part of C standard and not portable to other compilers.



__attribute__((packed)) : informing compiler not to do padding for aligning data of a struct in most cases.
                          Inside Paranthesis insted of packed we can also have other attribute.  

__attribute__((aligned(4))) : Aligned attribute specify memory alignment for data in the power of two : 2,4,8,16...

                                                                   
 
Example 1 : int8_t foo __attribute__((aligned(4))); informing compiler to define a word (32-Bits) 
            size boundary for foo variable whoch otherwise had taken a bondary of byte size.
            By boundary we mean memory locations provided to data type regardless of it´s original size.

Example 2 : typedef struct {
            int8_t var1;
            int32_t var2;
            int8_t var3;  
            }str1;

Now if we do alignment of structure members to occupy a boundary of word in memory as : 
            typedef struct {
            int8_t var1__attribute__((aligned(4)));  
            int32_t var2__attribute__((aligned(4)));
            int8_t var3__attribute__((aligned(4)));  
            }str1;
           
Now structure memebrs will be occupying 12 Bytes (truncated to 16 Bytes) instead of 6 bytes in memory before alignment. 

We can also do alignment on entire structure as :            
            typedef struct {
            int8_t var1;  
            int32_t var2;
            int8_t var3;
            }str1__attribute__((aligned));;

Example 3 : To pack our entire strucutre in memory we apply packed attribute in entire structure,now our memory is not aligned
            not efficient for CPU performance but effective for reducing memory consumption.

            typedef struct {
            int8_t var1;  
            int32_t var2;
            int8_t var3;
            }str1__attribute__((packed));;

__attribute__((always_inline)) : Informing compiler not to ignore inline keyword which we use at the time of function
                                  definition i.e.
Example 4: 
__attribute__((always_inline)) inline int32_add (int32_t x,int32_y )
                                 {
                                 
                                 } 
inline keyword placed with function name informs the compiler to place function code at the
calling section of code instead of doing context switching from caller to the function.

inline keyword is a C99 feature not present in c89 standard.
always_inline attribute is a GCC attribute not supported inother compilers. 

-----Function Pragmas---------

They provide special instructions to compiler and we can do it through
  Push/Pop - Add/Remove extra option for compilation for a part of code.
  Optimize - Specifies a certain level of optimization for block of code.

Example : 
#pragma GCC push
#pragma GCC optimize ("O0") 
int32_t add(int32_t x,int32_t y) 
{
return (x+y);
}
#pragma GCC pop  // Disabling use optimize function pragma


If we are working in embedded teams with different compilers and architectures then gcc attributes will not be supported so
to avoid compile time errors we do 
   #ifndef(__GNUC__)          
   #define__attribute__(x)  // This preprocessor directive will define as nothing for non GCC compilers 
   #endif

-------------Lec 8 : Memory Map and Registers--------------

Memory Map Provides a memory address to physical device mapping with an address space for use in programming.
Cortex M CPU Registers are not part of memory map can only be accessed through inline assembly instructions in our C Code.

We use pointers to access memory map.

A microcontroller can have following categories of memory registers : 
Core CPU Registers,
Internal Private Registers,
External Private Regsiers,
General Peripheral Memory Registers.

Cortex M CPU Registers are : General Purpose Registers R0-R12,
                             Special Purpose Registers R13 - R15(Link Register,Stack Pointer,Program Counter),
                             
Cortex M CPU Special Function Registers : Program Status Registers (APSR,IPSR,EPSR)
                                          Exception Mask Registers (PRIMASK,FAULTMASK,BASEPRI).
                                          Control Register.
To Access special purpose registers assembly language instructions are : MRS r1,BASEPRI  (for reading)
                                                                         MSR FAULTMASK,r0 (for writing)


Program Status Register: Captures the current state of program and combines :-
                         Application Program status Register (APSR) : Contains current state of condition flags from previous instruction.
                         Interrupt Program Status Register (IPSR)  : Contains exception type number of current ISR.
                         Exception Program Status Register(EPSR).            

Control Register : Allows the processor to move in between privilege and non privileged state.

     
To access Timer TA0 Control Register with address 0x40000000 we do : volatile uint16_t * ta0_ctrl = (uint16_t*)0x40000000;
        Writing a value to register to set it´s specific bit fields : *ta0_ctrl = 0x0202;


------------------------------LEC 9 : Register Definition File-----------------------

Register Definition Files are used to access peripheal registers as they contain addresses of these peripheral registers. These files are provided by chip vendors
mostly and we are not required to develop it ourselves. We just need to develop external peripheral or sensor register definition file during our driver development.
In both above scenarios we use #define preprocessor directive.

Register defintion file provides a hardware abstraction to the embedded software developers.

Register Definition File : 
Provides interface to Peripheral Memory by specifying : Address list for peripherals , 
                          				Access Methods,
							Defines for bit fields and Bit masks.

Peripheral Access Methods are used to Read/Write Data : Direct Dereferencing of Memory,
							Structure Overlays. 

  

-----------Memory Access Macros------------

We can use pre processor directive #define to develop access methods without using hardcoded values for 8,16,32,64 bits of peripheral registers i.e.

#define HWREG8(x)    (*((volatile uint8_t*)(x)))        // Here we are first casting address x that we will only need 8 bits of this location and later we are accessing this location
                                                        // and can either read or assign a new value to it , hence we can access any peripheral register with address x.
                                                        // vloatile keyword informing compiler to not do optimization. 
#define HWREG16(x)   (*((volatile uint16_t*)(x)))
#define HWREG32(x)   (*((volatile uint32_t*)(x)))

#define TA0CTL       (HWREG16(0x40000000))             // Here we are passing peripheral register address 0x40000000 and can only 16 bits of it in our code i.e.

Similarly for other registers we can do 

#define TA0CCTL0      (HWREG16(0x40000002))            // Here we are passing peripheral register address 0x40000002 and can only 16 bits of it in our code i.e.
#define TA0CCTL1      (HWREG16(0x40000004))
#define TA0CCTL2      (HWREG16(0x40000006)) 
#define TA0CCTL3      (HWREG16(0x40000008))
#define TA0CCTL4      (HWREG16(0x4000000A))
#define TA0R          (HWREG16(0x40000010))

int main(){

TA0CTL = 0x202;      // This line expands (HWREG16(0x40000000)) = 0x202 leading to assigning of value 0x202 to peripheral register but only 16b bits are altered.

}

To compile our code for different platforms with different peripheral registers with varying addresses we can introduce compile time switches for 
appropriately including relevant include file according to the target architecture as : 

#ifdef MSP432_VER1
#include "MSP432_Version1.h"                // for one chipset with different peripheral register address
#else
#include "TM4C123G.h"                       // For another chipset with it´s own peripheral register addresses "

#endif


---------------Structure Overlay Macros---------------
We use structure pointer and dereference it to access the indvividual registers.




typedef struct {
__IO uint16_t CTL;
__IO uint16_t CCTL[7];
__IO uint16_t R;
__IO uint16_t CCR[7];
__IO uint16_t EXO;
uint16_t RESEVDO[6];
__I uint16_t IV;
}Timer_A_Type;

#define PERIPH_BASE ((uint32_t)0x40000000)
#define TIMER_A0_BASE (PERIPH_BASE + 0x000000)
#define TIMER_A0 ((Timer_A_Type*)Timer_A0_BASE)
#define __IO (volatile)
#define __I (volatile const)

int main(){

TIMER_A0->CTL=0x0202;    // This macro line will expand into ((Timer_A_Type*)(PERIPH_BASE + 0x000000))---> ((Timer_A_Type*)((uint32_t)0x40000000 + 0x000000))-->CTL=0x202
                                                                                                    Where we´ve casted address ((uint32_t)0x40000000 + 0x000000)) as 
                                                                                                    struct address                                                                                                       
}




--------------------------------------------Week2 : Manipulating Memory---------------------------------------------
 
We use bitwise operators to manipulate,change certain bits of memory and External Peripheral Registers.

Toggle a bit means change it´s current state if it´s 1 then change it to 0 , if it´s 0 then change it to 1.

Bit Masks : Constant expressions used to set,clear or toggle a specific set of bits.

Instead of using constant numeric values in expressions like : 
uint8_t foo
foo |= 0x30 ; 

We should use macros to make our code more readable i.e #define MASK1 (0x30)

In many cases the vendor may also provide pre made bit masks in register definition values for interfacing peripheral registers like : 

#define BIT0 (uint16_t)(0x0001)


----------Bit Banded Region --------------

In ARM Only first One Mega Byte of peripheral and SRAM memory is bit banded meaning each bit has it´s own address and can be accessed through a pointer for read,modify operations.

----------Lec 4: Creating Software Interfaces Of Hardware---------------
HAL (Hardware Abstraction Layer ) is created to simplify application level programming, it acts like a
API(Application Programming Interface) Enabling us to focus on our application instead of initializing a certain microcontroller peripheral,interface,functionality through it´s numerous registers.

ARM CMSIS (Cortex Microcontroller System Interface) also provides us a similar interface with abstraction layer offering portability across its different architectures.

Creation of a SW interface for our hardware involvs different solutions such as : 

Register Definition File : Providing Interface to peripheral memory, Access Methods, Defines for Bit Fields and Bit Masks.
                           Peripheral Methods we use to read/write data through macros, structure overlays and direct dereferencing of memory leads to single platform architecture.


For writing a HAL Layer interface methods we use Macro Functions and Specialized C-Functions  for portability and readability.

Macros can become complex and are not possible to be debugged as they are a part of preprocessor so we can use inline functions in the HAL layer but their too much use can also increase our code size
as they will copy paste our function code at the calling statement.

In line function solution : 

Example
__attribute__((always_inline)) static inline void__enable_irq(void){   // can be defined without static then it will not be private.
                                                                       // here compiler is assuming all linkage is internal to the file where this function is defined.

// function statements

}

---------------------Lec 5 : Advanced Pointers Use-----------------------

Some other pointer types we´ve in C are void pointers, double pointers , restrict pointers.

Void Pointers : Generic Pointers, point to a memory address, need to be casted to a type before dereferencing, pointer arithmetic can´t be performed, size of a void pointer is equal 
                to the size of word of the architecture.


Restrict Qualifier Pointer : Helps compiler to optimize memory interactions as it´s the only address pointing to location, Introduced in C99 Standard,
                             Syntax : uint8_t * restrict ptr;



Double Pointer : Pointer to a Pointer, Used to set value of a pointer.    uint8_t **dptr = &ptr1;         
                 Single dereference accesses pointer address.             printf("Address Stread at Double Pointer = %p",*dptr);  
                 Double dereference accesses pointer data.                printf("Valued Stored At Address Stored At Double Pointer = %x",**dptr;

Example 1 : Copies of Pointers are made when passed into a function 

typedef enum{
RSP_TYPE_1 = 0,
RSP_TYPE_2 = 1,
}RSP_e;

typedef struct {
RSP_e rsp_stype;
uint8_t data[4];
}rspl;

int8_t create_rsp1 (rspl ** r_p ) {
*r_p = (rspl *)malloc(sizeof(rsp1));    //Here we´ve changed address stored at double pointer r_p however address external to function remains unchanged

if(*r_p == NULL) {
return -1 ;
}

(*r_p)->rsp_type = RSP_TYPE_1;
return 0;

}



Example 2 :      

Memory Address    :        Values or Addresses
0x10                           0x13
0x11                           0xff
0x12                           0x03
0x13                           0x77


uint8_t * ptr = (uint8_t*)0x10;         // Assigning Address 0x10 to ptr and reading 8 bits at that address

uint8_t **dptr = &ptr;                  // Assigning Own Address Of Pointer ptr (it´s not 0x10) pointing to 0x10

uint8_t *ptr2 = **dptr;                 // Assigning value (0x13) pointed by address stored at ptr *dptr = ptr = 0x10 ; **dptr = *(0x10) = 0x13 

uint8_t foo = *ptr2;                    // It´s *(0x13) = 0x77
 

Example 3 : 
int main(){

uint8_t a = 0x12;
uint8_t *ptr1 = &a ;
uint8_t **ptr2 = &ptr1;

printf("Address of Variable a = %p \n",&a);

printf("Address Of Pointer Ptr1 = %p \n",&ptr1);
printf("Address  Stored At Pointer Ptr1 Memory Location %p = %p\n",&ptr1,*(&ptr1));

printf("Address Stored In Pointer Ptr1 = %p \n",ptr1);


printf("Double Pointer Ptr2 Address : %p  \n",&ptr2);
printf("Double Pointer Memory Location %p Has Address Stored %p -----> %p -----> Value: %x \n",&ptr2,ptr2,*ptr2,**ptr2);

return 0;
}

------------------Lec 6 : Function Pointers----------------------

Function Pointer : Pointer that points to functions.
                   Defined just like a function, Has : 
                       Return Type.
                       Function Paramters.     
                       Pointer Name
Dereferencing a function pointer will call a function.


Function Pointer Declaration Syntax : 
<type> (*<function_pointer_name>)(<parameters list>) = <function-address>;    // type = int,float ....    ,function_pointer_name = fptr, function address = &func_name;

The type of function pointer is the return type of function pointed by function pointer.
            paramters list are the values to be passed t othe function being pointed.

Example : 1 

uint8_t add(int a,int b){
uint8_t sum = a+b;
return sum;
}

int main(){
int ret_sum;
uint8_t(*fptr)(int,int);
*fptr=&add;

ret_sum=fptr(1,2);    //calling add function through function pointer very similar to if we had call´d add function as add(1,2);


return 0;
}

Example 2 : We can also use typedef to create a new type used for creating function pointers i.e.

typedef int(*fptr_TYPE)(int a,int b);

fptr_TYPE fptr1 = &foo;
fptr_TYPE fptr2 = &bar;

Example 3 :  We can also have an array of function pointers as :

typedef int (*fptr_t[2])(int a,int b)

fptr_t example = 
{
foo,
baa
};

to call or invoke function pointers in array we do : 

example[1]();   // Calling foo function pointer function, Where in brackets () we can also pass paramters.
example[2]();   // Calling baa function pointer function,

----------------------Lec 7 : Debugging a Microcontroller------------------------

Debug symbols should be enabled at compile time by -g flag of compiler in order for debugger to work properly.




-------------------------------Week 3 : Designing Embedded Data Structures-----------------------




-----------------Lec 1 ------------------- 


Structures allow us to create our own types made of : Standard C Types , Derived types, Enumerated Types e.t.c.
Data Strucutres help us to manage data.

C programming has four derived types : Pointers, Arrays, Structures, Unions.


---------------Lec 2 : Enumerations----------------

Enumerations are a alternative to #defines and const type qualifiers , Enumerations are a enumerated integer only data type.
Enumerations allows us to assign names to constant values and enable us to do type checking at compile time, not possible using #define. 
Enumerations can have default values assigned by  compiler or we can assign them.
Enumerations does not reserve memory , only declared enumerated type takes memory.
Enumerations are especially useful for assigning error & status codes. 

Enumerated Member item type assigned value size is normally equal to unsigned int or signed int, Multiple implementations may exist according to ABI´s .
Enum member item names have a global scope so we should not have two enumerations with same member enum item name.
Enums can also be used to index an array.
Enum sizes can also be optimized using gcc compiler flag -fshort-enums   // Where instead of short we could have specified anyother type whose size we intend to assign.

Syntax : 
enum <enum_type> {
<enum_name> = <enum_value>,
<enum_name> = <enum_value>,
<enum_name>,
// More enumerations
};

Example 1 : 

enum month {
JANUARY = 1,
FEBRUARY = 2,
MARCH = 3,
APRIL = 4,
MAY = 5,
JUNE = 6,
JULY = 7,
AUGUST = 8,
SEPTEMBER = 9,
OCTOBER = 10,
NOVEMBER = 11,
DECEMBER = 12
};

enum month m;    // Where sizeof(m) = 


Example 2 : 

if(m==JANUARY)
{ 
printf(" First Month : ");
}

Example 2 :
typedef enum {
NO_ERROR = 1,
POWER_ERROR = 2,
BUS_ERROR
}Error_e;

Error_e error ;   // Now we can enumerate on entire enumerated list through a for loop and make comparisons using if statements.



---------------------------Lec 3 : Unions-----------------------

Unions are a derived data type containing multiple data members (structs,variables,pointers e.t.c.) of different sizes occupying the same address. 
Size of a union is equal to largest member.
Unios are regularly in header file (core_cm4.h) of ARM CMSIS Interface .
We may use unions as a shared memory resource in Multithreaded application , this shared memory resource can be allocated through linker script as well rather
than dynamically allocating and deallocating memory using malloc.


Syntax : union <umion_type> {
         <type> <name>;
         <type> <name>; 
        };

Example 1 :     typedef union {
                uint8_t x;
                uint8_t y;     
                uint8_t z;
                } ex1;
             
               ex1 point;
              point.x = 1;      //now all members have same value of 1.

Example 2 :  
             typedef struct {
             uint8_t x;
             uint8_t y;
             uint8_t z;
             }Str1_t;
 
             typedef struct {
             uint32_t x;
             uint32_t y;
             uint32_t z;
             } Str2_t;

            typedef union {
            Str1_t s1;
            Str2_t s2;
            }ex3_t;

            ex3.s1.x = 0x12; 
            ex3.s2.y = 0x1567;

------------------------------Lec 4 : Structures and Encapsulation------------------


Structures require to be decalred with struct keyword.
Each structure requires a unique name.
A structure has list of members.
We can place our strucutre in a header file or in implementation file depending upon our requirement.
Structures can contain basic types(bool,char,int,float,double) , derived types(enum,pointers,functions,other structures).
We can also use typedef similar to union to create our own types.
Same rules of type qualifiers static,const similar to variables also apply here.
We can also have struct pointers and an array of structure pointers in both cases a struct pointer points to a structure.

Syntax : struct <STRUCT-NAME> {
         <TYPE_NAME> <MEMBER-NAME>;
         <TYPE_NAME> <MEMBER_NAME>;
         };    
         
Example 1 : struct WeatherSample{ 
           float temp;
           uint8_t wind_s;
           uint8_t wind_d;
           uint16_t humidity;
           uint8_t sun;
           time_t;
           }

          struct WeatherSample S1;
          S1.temp = val; 
 
Example 2 : typedef struct{ 
           float temp;
           uint8_t wind_s;
           uint8_t wind_d;
           uint16_t humidity;
           uint8_t sun;
           time_t;
           }WeatherSample_t;

        WeatherSample_t ws1;
        WeatherSample_t *sptr;
        WeatherSample_t s_a[10];     // An array of WeatherSample_t structures.
        ws1.temp = val;   

Structure Encapsulation is just based upon read/write operation on it´s members through functions either containing that struct pointer in it´s body or having struct pointer passed as a paramter to it.  For Example : 

       void gather_sample(WeatherSample **w);

       float get_temp(WeatherSample *w);
       uint8_t get_humidity(WeatherSample *w);
       time_t get_time(WeatherSample *w);
       void print_weather(WeatherSample *w);

               
Composite Data Structures : Structures defined using only built-in C-types and/or other composite data types
Abstract Data Structures : Structures that can be applied to any number of applications. 
                            Need to define structure and interface methods allowing : Addition Of New Data,
                      								      Removing Data,
										      Initializing a Structure
										      Clearing a Structure.	

                          Examples Of Abstract Data Structres : Linked Lists (Single,Double,Circular),
                                                                Stack (FIFO,LIFO,Circular),
                                                                Trees (Binary,Binary Search),
                                                                Hash Table. 
 
---------------------------------Lec 5: Bit Fields-------------------------------------

Bit fiels allow us to calculate read, write data within a union or struct that is smaller than a byte.
We just use a colon : after struct or union name to assign specific number of bits.

Example 1 : 
          struct <name>{
          uint32_t w:BITSIZE;
          uint32_t x:BITSIZE;
          uint32_t y:BITSIZE;
          uint32_t z:BITSIZE;
};


If we have bit field struct members of the same type then they will be packed at the same memory location until they cannot fit in and we can later on 
access these member bits as well and perform read/write operation as well without affecting each one of their bits. 

Bit Field concept is similar to packing of data as bit fields pack one bit right after another until type size is met or exceeded.

Reading/Writing Bit fields implicitly use bit manipulation operations leading to reduction in execution efficiency, increasing our storage efficiency.

We can try to mitigate above problem of alignment by adding a dummy bit field forcing a particular alignment i.e. Using :o with no bit limit.

Example 2 : struct example6 { 
            uint32_t x:16;
            uint32_t y:4;
            uint32_t :0;
            uint32_t z:10;
            };


---------------------Lec 6: LIFO Buffer---------------------------------

LIFO Buffer is a memory allocated either on heap or in a array. 
This ia contigous memory consisting of memory locations.
LIFO Buffer is used to solve the problem of synchronization between two processes communicating with each other at different exectuion speed ( Producer, Consumer ).


LIFO Buffer requires parameters to interact with that and they are : starting memory location (base address, *base_ptr), next memory location pointed address(*head_ptr), buffer length
                                                                     specifying number of memory locations.

Struct , Methods,  Functions Required : LB_Status LIFO_Is_Buf_Full(LIFO_BUF_t * lbuf);
                                        LB_Status LIFO_Add_Item (LIFO_Buf_t * lbuf,uint8_t item);
                                        <return_type> * create_buffer( <type> *ptr,<type> length ); // Here return type is the type of base pointer.
                                        // We may also include item remove function

typedef enum {        // STATUS CODES OF LIFO BUFFER STATUSES 
LB_NO_ERROR = 0,
LB_FULL,
LB_NOT_FULL,
LB_EMPTY,
LB_NOT_EMPTY,
LB_NULL,
}LB_Status;

typedef struct {
<type> length;         // Size of the LIFO Buffer
<type> *base;          // Pointer Pointing to the starting memory location address
<type> *head;          // Pointer Pointing to next memory location address
}LIFO_BUF_t;

LB_Status LIFO_Is_Buf_Full(LIFO_BUF_t  lbuf)
{

if( !lbuf.head || !lbuf.base ) 
{
return LB_NULL; 
}

if(lbuf.head == (lbuf.base+lbuf.length))
{
return LB_FULL;
}

else
return LB_NOT_FULL;
}

LB_Status LIFO_Add_Item (LIFO_BUF_t lbuf,uint8_t item) // This iteam can also be a struct or union, for that we will need to cast
                                                         // malloc pointer accordingly
{

if( LIFO_Is_Buf_Full(lbuf)!=LB_FULL)
{
*(lbuf.head) = item;
lbuf.head++;
return LB_NO_ERROR;
}

}



<return_type> * create_buffer( <type> *ptr,<type> length ) {
ptr->base = <type*>malloc(sizeof(length));   // Here we could have also used arrays instead of heap depending upon requirement.
return ptr;
}


------------------------Lec 9 : Circular Buffer-------------------------

Buffers can be implemented in Hardware or Software.
     They help in transmitting lots of data in our out of an interface (e.g.UART).

Circular buffer is also known as Ring Buffer and is a example of FIFO(First in First Out) Buffer.
     Created with a contigous block of memory.
Circular Buffer adds data to one end (Head).   ( Head is a pointer ).
Circular Buffer removes data items from the end (Tail).  ( Tail is a pointer).
Like LIFO  Circular Buffer Can also be implemented either through arrays or heap more generally.


In a circular buffer :- Head pointer either points to next memory empty location or current occupied memory location depending upon implementation.
                        Tail Pointer Points to last occupied memory location.
                                                                                               

The head will continue to grow in one direction until it has reached end of allocated region. 
If more data get´s added beyond the capacity of buffer, head will move back to begining of buffer i.e. it´s base address.
     




------Functions For Interfacing , Creating Circular Buffer----------------

// Circular Buffer Structure : 

typedef struct
{
uint8_t * Base;
uint8_t * Tail;
uint8_t * Head;
uint8_t Length;
uint8_t Count;
}CB_t;

typedef enum {        // STATUS CODES OF LIFO BUFFER STATUSES 
CB_NO_ERROR = 0,
CB_FULL,
CB_NOT_FULL,
CB_EMPTY,
CB_NOT_EMPTY,
CB_NULL,
}CB_Status;  

<return_type> * create_buffer( <type> *ptr,<type> length ) {
ptr->base = <type*>malloc(sizeof(length));   // Here we could have also used arrays instead of heap depending upon requirement.
return ptr;
}


CB_Status LIFO_Is_Buf_Full(CB_t  cbuf)   // Function Checking Status Of Buffer
{

if( ! cbuf->head || ! cbuf->tail || ! cbuf->base ) // Checking to make sure pointers are not NULL
{
return CB_NULL; 
}

if(cbuf.tail == (cbuf.head+1) || cbuf.head == cbuf.tail + (cbuf.length-1)    ) // 1st Condition Checking If tail address is ahead of head pointer address 
{                                                                              // 2nd Condition Checking If Head Address is last address of Buffer and is equal to sum of tail address is last address of buffer and head address is 
                                                                                  at start.
return CB_FULL;
}

else
return CB_NOT_FULL;
}


CB_Status CB_Add_Item (CB_t * cbuf, uint8_t item) 
{
if( ! cbuf->head || ! cbuf->tail || ! cbuf->base ) // Checking to make sure pointers are not NULL
{
return CB_NULL; 
}

if(LIFO_Is_Buf_Full(cbuf)==CB_FULL){
return CB_FULL;
}

*(cbuf.head)=item;

if(cbuf.head == cbuf.base+(cbuf.length)-1) 
{
cbuf->head = cbuf->base ;
}
else {
cbuf->head ++;
}
return CB_NO_ERRORS;
}


------------------------------Lec 10 : Linked List------------------------------

Linked list allow us to create a scattered data strucutre that can be allocated to random locations in memory but still in linear order. 

--------------Linked List Data Structure--------------

Comprised of many nodes they are : Independently allocated (On Heap or Stack or other memroy) , Linked to other nodes.

Singly Linked List :    1st Node points to 2nd Node 
                        2nd Node Points to 3rd Node. 
                        3rd Node Points to N Node.
                        Must keep track of head node. 
                        Cannot travel backwards ( As we can only search linked list from tail to head as we only have one pointer storing address of noext node)
                                                ( Singly linked list is also called forward linked list ) 


Doubly Linked List :    Can track any node.
                        Can travel forwards and backwards. 
                        Has address of next node and of previous node so it has two pointers in it´s data struct.


In Linked list tail node next pointer points to null.
If linked list is empty head node is null or isn´t even allocated.    

Node Structure : struct nod

                 typedef struct node{
                 uint8_t item;
                 struct node *next;    // 32 bit pointer address in 32 bit architecture pointing to next node in linked list.

                 }Node_t;  

One disadvantage of linked list is that we need to store every node 32 bit address in a node´s data strucutre.

Linked list nodes are added and removed thorughout lifetime of the program.
Linked list size grows and shrinks. 
     To add a node in list we need a method/function called append or insert.
     To remove a node from list we need a method/function called remove or freenode.

Here we are considering head node as the first node in list and tail as the last node in list.
To deallocated heap memory in Linked list we will need to track of head node , if we don´t then we have memory leak issue.

Function For Adding A Node To the End Of List i.e. Last Node ( Tail )

void LL_append (Node_t *node,uint32_t data){             

Node_t * nn = node;
if(node==NULL) {return ;}  			  // Checking if node was assigned or not heap memory address.

if(node->next == NULL)                            // Checking if current node is tail (last node)
{
node->next = (Node_t*)malloc( sizeof(Node_t) );   // If it´s last node then we are updating its next pointer with address of node allocated memory on heap
nn=node->next;                                    // Making newly added node as current tail (Last ) node
}
else{
while(nn->next!=NULL){                            // Traversing the entire list to check for tail (Last Node)
nn=nn->next;
}
nn->next = (Node_t*)malloc(sizeof(Node_t));       // If it´s last node then we are updating its next pointer with address of node allocated memory on heap
nn=node->next;                                    // Making newly added node as current tail (Last ) node
} 
}
nn->data = data;                                  // Appending data to the tail node in list.
nn->next = NULL;                                  // Making Newly Appended Node As Tail Node by making it´s next pointer to point to NULL.

}
  












